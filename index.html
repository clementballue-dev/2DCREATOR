<!doctype html>
<html lang="fr">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Mini-arÃ¨ne (prototype)</title>
<style>
  html,body { height:100%; margin:0; background:#111; color:#eee; font-family:Arial,Helvetica,sans-serif; }
  #gameWrap{ display:flex; height:100vh; align-items:center; justify-content:center; position:relative; }
  canvas { background:#2b7; border:6px solid #222; box-shadow:0 6px 30px rgba(0,0,0,0.6); }
  .ui {
    position:absolute; right:18px; bottom:18px; z-index:20; display:flex; flex-direction:column; gap:8px;
  }
  .btn {
    background:#0b84ff; color:white; border:none; padding:10px 14px; border-radius:8px; cursor:pointer;
    font-weight:700; box-shadow:0 4px 14px rgba(11,132,255,0.35);
  }
  .panel {
    position:absolute; left:18px; top:18px; background:rgba(0,0,0,0.55); padding:12px; border-radius:8px;
    min-width:220px; color:#fff;
  }
  .row { margin:6px 0; }
  label{display:block; font-size:13px; margin-bottom:6px;}
  select,input[type=color],input[type=text] { width:100%; padding:6px; border-radius:6px; border:1px solid #444; background:#222; color:#fff;}
  #overlayScreen {
    position:absolute; inset:0; display:flex; align-items:center; justify-content:center; z-index:30;
    pointer-events:none;
  }
  .screenBox {
    pointer-events:auto;
    background:rgba(10,10,10,0.9); color:#fff; padding:24px; border-radius:10px; text-align:center; width:min(600px,90%);
    box-shadow:0 10px 40px rgba(0,0,0,0.7);
  }
  .screenBox h1{ margin:0 0 12px; font-size:28px; }
  .hud {
    position:absolute; left:50%; transform:translateX(-50%); top:12px; z-index:25; color:#fff; text-align:center;
  }
  .barWrap { width:260px; height:14px; background:#333; border-radius:8px; overflow:hidden; margin:0 auto; border:1px solid #222;}
  .bar { height:100%; background:linear-gradient(90deg,#00d08a,#00a68f); width:100%; }
  .infoRow{display:flex; gap:12px; justify-content:center; margin-top:8px; font-size:14px;}
  .small { font-size:12px; opacity:0.9; }
  .leaderboard { margin-top:8px; background:#111; padding:8px; border-radius:6px; border:1px solid #222; max-height:150px; overflow:auto; font-size:13px;}
  .lb-row{ display:flex; justify-content:space-between; padding:4px 6px; border-bottom:1px solid #222; }
</style>
</head>
<body>
<div id="gameWrap">
  <canvas id="c" width="1000" height="600"></canvas>

  <!-- left panel: choix skin/arme + pseudo + leaderboard -->
  <div class="panel" id="panel">
    <div class="row">
      <label>Pseudo</label>
      <input type="text" id="pseudoInput" placeholder="Ton pseudo">
      <button class="btn" id="savePseudoBtn" style="margin-top:8px;">Sauvegarder pseudo</button>
    </div>

    <div class="row">
      <label>Choisir le skin (aperÃ§u simple)</label>
      <select id="skinSelect">
        <option value="0">Skin Bleu (par dÃ©faut)</option>
        <option value="1">Skin Rouge</option>
        <option value="2">Skin Vert</option>
        <option value="3">Skin Jaune</option>
      </select>
    </div>
    <div class="row">
      <label>Choisir l'arme</label>
      <select id="weaponSelect">
        <option value="pistol">Pistolet</option>
        <option value="shotgun">Pompe</option>
        <option value="sniper">Sniper</option>
        <option value="smg">Mitraillette</option>
      </select>
    </div>

    <div class="row small">DÃ©placements AZERTY: <strong>Z Q S D</strong> â€¢ Tir: <strong>Clic gauche</strong> â€¢ Recharger: <strong>R</strong></div>

    <div class="row">
      <label>Classement (couronnes)</label>
      <div class="leaderboard" id="leaderboard"></div>
    </div>
  </div>

  <!-- HUD center top -->
  <div class="hud" id="hud">
    <div class="barWrap"><div id="hpBar" class="bar" style="width:100%"></div></div>
    <div class="infoRow">
      <div id="hpText">Vie: 10 / 10</div>
      <div id="ammoText">Ammo: 10 / 10</div>
      <div id="roundText">Round: 0 / 3</div>
    </div>
  </div>

  <!-- bottom-right UI -->
  <div class="ui">
    <button id="joinBtn" class="btn">Simuler 2Ã¨me joueur</button>
    <button id="playBtn" class="btn">JOUER</button>
  </div>

  <!-- overlay screens -->
  <div id="overlayScreen"></div>
</div>

<script>
/* --------------------------
   Prototype ArÃ¨ne 2D (prototype Ã©tendu)
   - Modifs demandÃ©es ajoutÃ©es :
     * toutes les armes = 1 dÃ©gÃ¢t
     * player & bots = 10 HP
     * toutes les 5 balles tirÃ©es -> reload automatique 3s
     * distance limite pour les armes
     * match = best of 3 rounds (3 rounds max)
     * +10 couronnes au gagnant du match (classement local)
   - J'ai ajoutÃ© pseudo + leaderboard local (localStorage)
   -------------------------- */

const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');

let W = canvas.width, H = canvas.height;

// Game state
let game = {
  running:false,
  roundStartTime:0,
  bgColor:'#2b7',
  players:[],
  enemies: [],
  bullets: [],
  roundWinner:null,
  lobbySimulated:false,
  // match state:
  match: {
    roundsPerMatch: 3,
    currentRound: 0,
    playerRoundWins: 0,
    enemyRoundWins: 0
  }
};

// Settings UI
const skinSelect = document.getElementById('skinSelect');
const weaponSelect = document.getElementById('weaponSelect');
const playBtn = document.getElementById('playBtn');
const joinBtn = document.getElementById('joinBtn');
const overlayScreen = document.getElementById('overlayScreen');
const hudHpBar = document.getElementById('hpBar');
const hpText = document.getElementById('hpText');
const ammoText = document.getElementById('ammoText');
const roundText = document.getElementById('roundText');

const pseudoInput = document.getElementById('pseudoInput');
const savePseudoBtn = document.getElementById('savePseudoBtn');
const leaderboardEl = document.getElementById('leaderboard');

function randInt(a,b){ return Math.floor(Math.random()*(b-a+1))+a; }
function randChoice(arr){ return arr[Math.floor(Math.random()*arr.length)]; }
function rnd(min,max){ return Math.random()*(max-min)+min; }

const PLAYER_SIZE = 44;
const ENEMY_SIZE = 44;

// Controls (AZERTY)
const keys = { z:false,q:false,s:false,d:false, r:false };
window.addEventListener('keydown',(e)=>{
  const k=e.key.toLowerCase();
  if(k==='z') keys.z=true;
  if(k==='q') keys.q=true;
  if(k==='s') keys.s=true;
  if(k==='d') keys.d=true;
  if(k==='r') keys.r=true;
});
window.addEventListener('keyup',(e)=>{
  const k=e.key.toLowerCase();
  if(k==='z') keys.z=false;
  if(k==='q') keys.q=false;
  if(k==='s') keys.s=false;
  if(k==='d') keys.d=false;
  if(k==='r') keys.r=false;
});

// Mouse aim & click
let mouse = { x:W/2, y:H/2, down:false };
canvas.addEventListener('mousemove', e=>{
  const rect = canvas.getBoundingClientRect();
  mouse.x = e.clientX - rect.left;
  mouse.y = e.clientY - rect.top;
});
canvas.addEventListener('mousedown', e=>{ if(e.button===0) mouse.down = true; });
canvas.addEventListener('mouseup', e=>{ if(e.button===0) mouse.down = false; });

// Basic weapon definitions
// All dmg set to 1 per request. Added 'range' property (pixels).
const WEAPONS = {
  pistol: { name:'Pistolet', mag:10, fireRate: 300, bulletSpeed:700, dmg:1, reloadTime:900, spread:6, range:800 },
  shotgun: { name:'Pompe', mag:6, fireRate:900, bulletSpeed:600, dmg:1, pellets:6, pelletSpread:18, reloadTime:1400, range:220 },
  sniper: { name:'Sniper', mag:1, fireRate:2000, bulletSpeed:1200, dmg:1, reloadTime:1800, scope:true, range:1400 },
  smg: { name:'Mitraillette', mag:30, fireRate:80, bulletSpeed:900, dmg:1, reloadTime:1100, spread:8, range:900 }
};

// Player constructor
function createPlayer(){
  const skin = parseInt(skinSelect.value,10)||0;
  const weaponKey = weaponSelect.value || 'pistol';
  const weapon = Object.assign({}, WEAPONS[weaponKey]);
  weapon.key = weaponKey;
  weapon.ammo = weapon.mag;
  // shotsSinceAutoReload -> counts shots until forced reload every 5 shots
  weapon.shotsSinceAutoReload = 0;
  return {
    id:'p1',
    x:W/2, y:H/2,
    vx:0, vy:0,
    size:PLAYER_SIZE,
    speed:200,
    hp:10, // changed to 10
    maxHp:10,
    skin,
    weapon,
    canFire:true,
    lastFire:0,
    reloading:false,
    alive:true
  };
}

// Enemy AI
function createEnemy(i){
  const wkey = randChoice(['pistol','shotgun','smg']);
  const w = Object.assign({}, WEAPONS[wkey]);
  w.key = wkey;
  w.ammo = w.mag;
  w.shotsSinceAutoReload = 0;
  return {
    id:'e'+i,
    x: randInt(80, W-80),
    y: randInt(80, H-80),
    size:ENEMY_SIZE,
    speed: 120,
    hp:10, // bots also 10hp
    maxHp:10,
    state:'patrol',
    targetPoint: null,
    reactionTime: rnd(300,1200),
    lastSeeTime:0,
    lastAction:0,
    weapon: w,
    alive:true,
    aimNoise: rnd(3,10)
  };
}

// bullets: include origin and maxRange to enforce distance limit
// {x,y,vx,vy,owner,dmg,life,weaponKey, ox, oy, maxRange}
function spawnBullet(x,y,dx,dy,owner,weaponKey,dmg, maxRange){
  game.bullets.push({
    x,y,vx:dx, vy:dy, owner, dmg, life:2000, weaponKey,
    ox: x, oy: y, maxRange: maxRange || 1000
  });
}

// Start Round (handles match rounds)
function startRound(){
  // if starting first round of match, reset match counters
  if(game.match.currentRound === 0){
    game.match.playerRoundWins = 0;
    game.match.enemyRoundWins = 0;
  }

  // increment round counter
  game.match.currentRound++;
  // reset per-round state
  game.bullets = [];
  game.enemies = [];
  game.players = [];
  game.roundWinner = null;
  game.roundStartTime = performance.now();
  game.bgColor = `hsl(${randInt(0,360)} ${randInt(40,70)}% ${randInt(35,55)}%)`;

  const p = createPlayer();
  game.players.push(p);

  // spawn 1 enemy per round
  for(let i=0;i<1;i++) game.enemies.push(createEnemy(i+1));

  game.running = true;
  overlayScreen.innerHTML = '';
  updateHUD();
}

// Simulate other player join (local)
joinBtn.addEventListener('click', ()=>{
  game.lobbySimulated = !game.lobbySimulated;
  joinBtn.textContent = game.lobbySimulated ? '2Ã¨me joueur prÃ©sent (simulÃ©)' : 'Simuler 2Ã¨me joueur';
});

// Play button: if lobby simulated -> start, else wait small delay
playBtn.addEventListener('click', ()=>{
  if(game.lobbySimulated){
    startRound();
  } else {
    showOverlayMessage('En attente dâ€™un autre joueurâ€¦ (simulation)', 1500, startRound);
  }
});

// Overlay helper
function showOverlayMessage(msg, ms, cb){
  overlayScreen.innerHTML = `<div class="screenBox"><h1>${msg}</h1></div>`;
  setTimeout(()=>{
    overlayScreen.innerHTML = '';
    if(cb) cb();
  }, ms);
}

// Loop
let lastTime = performance.now();
function loop(now){
  const dt = Math.min(50, now - lastTime) / 1000;
  lastTime = now;
  update(dt);
  render();
  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);

// Leaderboard helpers (localStorage)
function getSavedPseudo(){ return localStorage.getItem('mini_arena_pseudo') || ''; }
function savePseudo(name){
  if(!name) return;
  localStorage.setItem('mini_arena_pseudo', name);
  if(!getCrownsFor(name)) setCrownsFor(name, 0);
  refreshLeaderboard();
}
function getCrownsFor(name){
  const v = localStorage.getItem('mini_arena_crowns_' + name);
  return v ? parseInt(v,10) : 0;
}
function setCrownsFor(name, n){
  localStorage.setItem('mini_arena_crowns_' + name, String(n));
}
function addCrownsTo(name, add){
  const cur = getCrownsFor(name) || 0;
  setCrownsFor(name, cur + add);
}
function refreshLeaderboard(){
  // scan localStorage keys for mini_arena_crowns_
  const list = [];
  for(let i=0;i<localStorage.length;i++){
    const k = localStorage.key(i);
    if(k && k.startsWith('mini_arena_crowns_')){
      const name = k.replace('mini_arena_crowns_','');
      const crowns = parseInt(localStorage.getItem(k),10) || 0;
      list.push({name,crowns});
    }
  }
  list.sort((a,b)=>b.crowns - a.crowns);
  leaderboardEl.innerHTML = '';
  if(list.length===0) leaderboardEl.innerHTML = '<div class="small">Aucun joueur pour lâ€™instant</div>';
  list.forEach(it=>{
    const row = document.createElement('div'); row.className='lb-row';
    row.innerHTML = `<div>${escapeHtml(it.name)}</div><div>${it.crowns} ðŸ‘‘</div>`;
    leaderboardEl.appendChild(row);
  });
}
function escapeHtml(s){ return String(s).replace(/[&<>"]/g, c=>({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;'}[c])); }

// Save pseudo button
savePseudoBtn.addEventListener('click', ()=>{
  const name = pseudoInput.value.trim();
  if(!name) return alert('Entre un pseudo valide');
  savePseudo(name);
  alert('Pseudo sauvegardÃ©: ' + name);
});

// preload pseudo and leaderboard
pseudoInput.value = getSavedPseudo();
refreshLeaderboard();

// Update HUD
function updateHUD(){
  const p = game.players[0];
  if(!p) return;
  const pct = Math.max(0, p.hp / p.maxHp) * 100;
  hudHpBar.style.width = pct + '%';
  hpText.textContent = `Vie: ${p.hp} / ${p.maxHp}`;
  ammoText.textContent = `Ammo: ${p.weapon.ammo} / ${p.weapon.mag}`;
  roundText.textContent = `Round: ${game.match.currentRound} / ${game.match.roundsPerMatch}`;
}

// Game update
function update(dt){
  if(!game.running) return;

  const p = game.players[0];
  if(!p || !p.alive) return;

  // movement AZERTY
  let mx=0,my=0;
  if(keys.z) my -= 1;
  if(keys.s) my += 1;
  if(keys.q) mx -= 1;
  if(keys.d) mx += 1;
  if(mx!==0 || my!==0){
    const len = Math.hypot(mx,my);
    mx /= len; my /= len;
    p.x += mx * p.speed * dt;
    p.y += my * p.speed * dt;
  }

  // clamp on map edges
  p.x = Math.max(p.size/2, Math.min(W - p.size/2, p.x));
  p.y = Math.max(p.size/2, Math.min(H - p.size/2, p.y));

  // firing
  handleFiring(p, dt, true);

  // reload key
  if(keys.r && !p.reloading && p.weapon.ammo < p.weapon.mag){
    reloadWeapon(p, p.weapon.reloadTime || 1000);
  }

  // Update bullets
  for(let i=game.bullets.length-1;i>=0;i--){
    const b = game.bullets[i];
    b.x += b.vx * dt;
    b.y += b.vy * dt;
    b.life -= dt*1000;
    // remove if out of bounds or life <=0 or distance exceeded
    const distTravelled = Math.hypot(b.x - b.ox, b.y - b.oy);
    if(b.life <= 0 || b.x< -50 || b.x>W+50 || b.y<-50 || b.y>H+50 || distTravelled > b.maxRange){
      game.bullets.splice(i,1);
      continue;
    }

    // collision with enemies/players
    if(b.owner === 'p1'){
      // hit enemy?
      for(let j=0;j<game.enemies.length;j++){
        const e = game.enemies[j];
        if(!e.alive) continue;
        if(pointInRect(b.x,b.y,e.x-e.size/2,e.y-e.size/2,e.size,e.size)){
          applyDamageToEnemy(e, b);
          game.bullets.splice(i,1);
          break;
        }
      }
    } else {
      // bullet from enemy -> hit player
      if(p.alive && pointInRect(b.x,b.y,p.x-p.size/2,p.y-p.size/2,p.size,p.size)){
        p.hp -= b.dmg;
        game.bullets.splice(i,1);
        if(p.hp <= 0){
          p.alive = false;
          game.running = false;
          endRound(false);
        }
        updateHUD();
      }
    }
  }

  // Update enemies AI
  game.enemies.forEach(enemyAIUpdate.bind(null, dt));
  // check enemy death => win round
  const aliveEnemies = game.enemies.filter(e=>e.alive);
  if(aliveEnemies.length===0){
    game.running = false;
    endRound(true);
  }
}

// helper: point in rect
function pointInRect(px,py,rx,ry,rw,rh){
  return px>=rx && px<=rx+rw && py>=ry && py<=ry+rh;
}

// apply damage to enemy
function applyDamageToEnemy(e, bullet){
  if(!e.alive) return;
  e.hp -= bullet.dmg;
  if(e.hp <= 0){
    e.alive = false;
  }
}

// reload (with custom forced time)
function reloadWeapon(entity, forcedTime){
  if(entity.reloading) return;
  entity.reloading = true;
  const t = forcedTime || (entity.weapon.reloadTime || 1000);
  setTimeout(()=>{
    entity.weapon.ammo = entity.weapon.mag;
    entity.weapon.shotsSinceAutoReload = 0;
    entity.reloading = false;
    updateHUD();
  }, t);
}

// handle firing for a shooter (player or enemy)
function handleFiring(shooter, dt, isPlayer){
  const weapon = shooter.weapon;
  if(shooter.reloading) return;
  // compute angle
  let aimX, aimY;
  if(isPlayer){
    aimX = mouse.x; aimY = mouse.y;
  } else {
    const p = game.players[0];
    if(!p) return;
    aimX = p.x + (p.vx||0) * 0.3 * 100;
    aimY = p.y + (p.vy||0) * 0.3 * 100;
    const angNoise = degToRad( rnd(-shooter.aimNoise, shooter.aimNoise) );
    const dx = aimX - shooter.x, dy = aimY - shooter.y;
    const ang = Math.atan2(dy,dx) + angNoise;
    aimX = shooter.x + Math.cos(ang)*100;
    aimY = shooter.y + Math.sin(ang)*100;
  }

  const now = performance.now();

  // If no ammo, auto reload
  if(weapon.ammo <= 0 && !shooter.reloading){
    // forced reload (weapon.reloadTime)
    reloadWeapon(shooter, weapon.reloadTime || 1000);
    return;
  }

  // Firing logic per weapon
  function doFireSingle(angle){
    const speed = weapon.bulletSpeed;
    const dx = Math.cos(angle)*speed;
    const dy = Math.sin(angle)*speed;
    spawnBullet(shooter.x, shooter.y, dx, dy, isPlayer ? 'p1' : shooter.id, weapon.key, weapon.dmg, weapon.range);
  }

  if(weapon.key === 'shotgun'){
    if((isPlayer && mouse.down) || (!isPlayer && canEnemySeeAndWantToShoot(shooter))){
      const can = now - (shooter.lastFire||0) > weapon.fireRate;
      if(can && weapon.ammo>0){
        shooter.lastFire = now;
        weapon.ammo--;
        weapon.shotsSinceAutoReload = (weapon.shotsSinceAutoReload||0) + 1;
        for(let i=0;i<weapon.pellets;i++){
          const baseAng = Math.atan2(aimY - shooter.y, aimX - shooter.x);
          const spr = degToRad( rnd(-weapon.pelletSpread, weapon.pelletSpread) );
          const ang = baseAng + spr;
          doFireSingle(ang);
        }
        if(isPlayer) updateHUD();
        // check auto forced reload after 5 shots
        if(weapon.shotsSinceAutoReload >= 5){
          reloadWeapon(shooter, 3000); // forced 3s reload
        } else if(weapon.ammo===0){
          reloadWeapon(shooter);
        }
      }
    }
  } else {
    if((isPlayer && mouse.down) || (!isPlayer && canEnemySeeAndWantToShoot(shooter))){
      const can = now - (shooter.lastFire||0) > weapon.fireRate;
      if(can && weapon.ammo>0){
        shooter.lastFire = now;
        weapon.ammo--;
        weapon.shotsSinceAutoReload = (weapon.shotsSinceAutoReload||0) + 1;
        const ang = Math.atan2(aimY - shooter.y, aimX - shooter.x);
        const spreadDeg = weapon.spread || 0;
        const angWithSpread = ang + degToRad( rnd(-spreadDeg, spreadDeg) );
        doFireSingle(angWithSpread);
        if(isPlayer) updateHUD();
        if(weapon.shotsSinceAutoReload >= 5){
          reloadWeapon(shooter, 3000); // forced 3s reload
        } else if(weapon.ammo===0){
          reloadWeapon(shooter);
        }
      }
    }
  }
}

// enemy decision: whether they want to shoot (line of sight, reaction delay)
function canEnemySeeAndWantToShoot(enemy){
  const p = game.players[0];
  if(!p || !p.alive || !enemy.alive) return false;
  const dx = p.x - enemy.x, dy = p.y - enemy.y;
  const dist = Math.hypot(dx,dy);
  if(dist > 700) return false;
  const now = performance.now();
  if(now - enemy.lastSeeTime < enemy.reactionTime) {
    enemy.lastSeeTime = now;
    return false;
  }
  if(enemy.reloading) return false;
  return enemy.weapon.ammo > 0;
}

// enemy AI update
function enemyAIUpdate(dt, enemy){
  if(!enemy.alive) return;
  const p = game.players[0];
  if(!p || !p.alive) return;
  const now = performance.now();

  if(!enemy.targetPoint || now - enemy.lastAction > randInt(1000,3000)){
    enemy.targetPoint = { x: randInt(80, W-80), y: randInt(80, H-80) };
    enemy.lastAction = now;
  }

  const dx = enemy.targetPoint.x - enemy.x;
  const dy = enemy.targetPoint.y - enemy.y;
  const distToPoint = Math.hypot(dx,dy);
  if(distToPoint > 8){
    const nx = dx/distToPoint, ny = dy/distToPoint;
    enemy.x += nx * enemy.speed * dt;
    enemy.y += ny * enemy.speed * dt;
  } else {
    if(Math.random() < 0.01) enemy.targetPoint = null;
  }

  const pdx = p.x - enemy.x, pdy = p.y - enemy.y;
  const pdist = Math.hypot(pdx,pdy);
  if(pdist < 260 && Math.random() < 0.02){
    const angle = Math.atan2(pdy,pdx) + (Math.random()>0.5 ? Math.PI/2 : -Math.PI/2);
    enemy.x += Math.cos(angle) * 30;
    enemy.y += Math.sin(angle) * 30;
  }

  enemy.x = Math.max(enemy.size/2, Math.min(W - enemy.size/2, enemy.x));
  enemy.y = Math.max(enemy.size/2, Math.min(H - enemy.size/2, enemy.y));

  if(enemy.weapon.ammo <= 0 && !enemy.reloading){
    enemy.reloading = true;
    setTimeout(()=>{ enemy.weapon.ammo = enemy.weapon.mag; enemy.weapon.shotsSinceAutoReload = 0; enemy.reloading=false; }, enemy.weapon.reloadTime || 1000);
    return;
  }

  if(canEnemySeeAndWantToShoot(enemy) && (Math.random() < 0.025 || pdist < 300)){
    handleFiring(enemy, dt, false);
  }
}

// Rendering
function render(){
  ctx.fillStyle = game.bgColor;
  ctx.fillRect(0,0,W,H);
  drawArenaGrid();

  game.bullets.forEach(b=>{
    ctx.beginPath();
    ctx.fillStyle = (b.owner === 'p1') ? '#ffeb3b' : '#ff6161';
    ctx.arc(b.x,b.y,4,0,Math.PI*2);
    ctx.fill();
  });

  game.enemies.forEach(e=>{
    if(!e.alive) return;
    drawCharacter(e.x, e.y, e.size, '#d14', '#8a0', e.hp / e.maxHp);
  });

  const p = game.players[0];
  if(p){
    if(p.alive){
      const skinColor = getSkinColor(p.skin);
      drawCharacter(p.x, p.y, p.size, skinColor, '#333', p.hp / p.maxHp, true, p.weapon.key);
    } else {
      ctx.fillStyle = '#400';
      ctx.fillRect(p.x - p.size/2, p.y - p.size/2, p.size, p.size);
    }
  }

  drawCrosshair(mouse.x, mouse.y);
}

// draw grid
function drawArenaGrid(){
  const spacing = 40;
  ctx.save();
  ctx.globalAlpha = 0.08;
  ctx.lineWidth = 1;
  ctx.strokeStyle = '#000';
  for(let x=0;x<W;x+=spacing){
    ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,H); ctx.stroke();
  }
  for(let y=0;y<H;y+=spacing){
    ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(W,y); ctx.stroke();
  }
  ctx.restore();
}

// draw character as square (kept as in original)
function drawCharacter(x,y,size, color, trimColor, healthPct, drawGun=false, weaponKey='pistol'){
  ctx.save();
  // shadow
  ctx.fillStyle = 'rgba(0,0,0,0.25)';
  ctx.beginPath();
  ctx.ellipse(x, y + size*0.5, size*0.85, size*0.28, 0, 0, Math.PI*2);
  ctx.fill();

  const w = size * 0.9, h = size * 0.9;
  ctx.fillStyle = color;
  ctx.fillRect(x - w/2, y - h/2, w, h);

  const headW = w*0.6, headH = h*0.28;
  ctx.fillStyle = shade(color, -10);
  ctx.fillRect(x - headW/2, y - h/2 - headH*0.3, headW, headH);

  ctx.strokeStyle = trimColor;
  ctx.lineWidth = 2;
  ctx.strokeRect(x - w/2, y - h/2, w, h);

  const barW = w, barH = 6;
  ctx.fillStyle = '#333';
  ctx.fillRect(x - barW/2, y - h/2 - 16, barW, barH);
  ctx.fillStyle = '#0bda85';
  ctx.fillRect(x - barW/2, y - h/2 - 16, barW * (healthPct||0), barH);

  if(drawGun){
    drawGunOn(ctx, x, y, weaponKey);
  } else {
    ctx.fillStyle = '#222';
    ctx.fillRect(x + w*0.25, y - 4, 18, 6);
  }

  ctx.restore();
}

function drawGunOn(ctx, x, y, weaponKey){
  const dx = mouse.x - x, dy = mouse.y - y;
  const ang = Math.atan2(dy,dx);

  ctx.save();
  ctx.translate(x, y);
  ctx.rotate(ang);
  if(weaponKey === 'pistol'){
    ctx.fillStyle = '#111';
    ctx.fillRect(12, -6, 34, 12);
    ctx.fillStyle = '#666';
    ctx.fillRect(-6, -6, 20, 12);
  } else if(weaponKey === 'shotgun'){
    ctx.fillStyle = '#2b2';
    ctx.fillRect(12, -8, 48, 16);
    ctx.fillStyle = '#111';
    ctx.fillRect(-6, -8, 24, 16);
  } else if(weaponKey === 'sniper'){
    ctx.fillStyle = '#111';
    ctx.fillRect(12, -5, 64, 10);
    ctx.fillStyle = '#444';
    ctx.fillRect(-8, -6, 24, 12);
  } else if(weaponKey === 'smg'){
    ctx.fillStyle = '#3a3aff';
    ctx.fillRect(12, -6, 46, 12);
    ctx.fillStyle = '#111';
    ctx.fillRect(-6, -6, 20, 12);
  } else {
    ctx.fillStyle = '#111';
    ctx.fillRect(12, -6, 34, 12);
    ctx.fillRect(-6, -6, 20, 12);
  }
  ctx.restore();
}

function drawCrosshair(x,y){
  ctx.save();
  ctx.strokeStyle = '#fff';
  ctx.globalAlpha = 0.9;
  ctx.beginPath();
  ctx.moveTo(x-12,y); ctx.lineTo(x-4,y);
  ctx.moveTo(x+4,y); ctx.lineTo(x+12,y);
  ctx.moveTo(x,y-12); ctx.lineTo(x,y-4);
  ctx.moveTo(x,y+4); ctx.lineTo(x,y+12);
  ctx.stroke();
  ctx.restore();
}

function shade(hex, percent) {
  try{
    if(hex.startsWith('hsl')) return hex;
    hex = hex.replace('#','');
    const r = parseInt(hex.substring(0,2),16);
    const g = parseInt(hex.substring(2,4),16);
    const b = parseInt(hex.substring(4,6),16);
    const t = percent<0?0:255;
    const p = Math.abs(percent)/100;
    const R = Math.round((t - r) * p) + r;
    const G = Math.round((t - g) * p) + g;
    const B = Math.round((t - b) * p) + b;
    return `rgb(${R},${G},${B})`;
  }catch(e){ return hex; }
}
function degToRad(d){ return d * Math.PI / 180; }
function getSkinColor(idx){
  switch(idx){
    case 0: return '#4da6ff';
    case 1: return '#ff6b6b';
    case 2: return '#5ad66a';
    case 3: return '#ffd166';
    default: return '#4da6ff';
  }
}

// End of round handling: handle rounds per match and crowns
function endRound(playerWon){
  // update round win counters
  if(playerWon) game.match.playerRoundWins++;
  else game.match.enemyRoundWins++;

  // show round result and either start next round or end match
  overlayScreen.innerHTML = `
    <div class="screenBox">
      <h1>${playerWon ? 'Round GagnÃ© !' : 'Round Perdu'}</h1>
      <p>Score: Tu ${game.match.playerRoundWins} - Bot ${game.match.enemyRoundWins}</p>
      <p>Prochain round dans 1.5s...</p>
    </div>
  `;

  setTimeout(()=>{
    overlayScreen.innerHTML = '';
    // if match not finished and rounds left -> start next round
    const roundsNeeded = Math.ceil(game.match.roundsPerMatch / 2);
    if(game.match.playerRoundWins >= roundsNeeded || game.match.enemyRoundWins >= roundsNeeded || game.match.currentRound >= game.match.roundsPerMatch){
      // match finished
      const playerWonMatch = game.match.playerRoundWins > game.match.enemyRoundWins;
      showMatchEnd(playerWonMatch);
    } else {
      startRound(); // start next round
    }
  }, 1500);
}

function showMatchEnd(playerWonMatch){
  // award crowns if player won match
  const name = getSavedPseudo() || 'Anonyme';
  if(playerWonMatch){
    addCrownsTo(name, 10); // +10 couronnes
    refreshLeaderboard();
  }

  overlayScreen.innerHTML = `
    <div class="screenBox">
      <h1>${playerWonMatch ? 'VICTOIRE DU MATCH !' : 'DÃ‰FAITE DU MATCH'}</h1>
      <p>${playerWonMatch ? '+10 couronnes' : ''}</p>
      <p>Score final: Tu ${game.match.playerRoundWins} - Bot ${game.match.enemyRoundWins}</p>
      <div style="margin-top:12px;">
        <button class="btn" id="restartBtn">Rejouer match</button>
      </div>
    </div>
  `;

  document.getElementById('restartBtn').addEventListener('click', ()=>{
    // reset match count and start new match
    game.match.currentRound = 0;
    game.match.playerRoundWins = 0;
    game.match.enemyRoundWins = 0;
    overlayScreen.innerHTML = '';
    startRound();
  });
}

// preload HUD
updateHUD();
refreshLeaderboard();

//////////////////////////////////////
// END â€“ existing code structure preserved
//////////////////////////////////////

// NOTE: No further removals â€” code preserved & extended.

</script>
</body>
</html>

